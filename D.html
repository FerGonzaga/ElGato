<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP</title>
    <style>
        body {
            background-color: #3498db; /* Color sólido de fondo para el body */
            margin: 0;
            padding: 0;
            height: 100vh;
        }

        .transparente {
            background-color: rgba(255, 255, 255, 0.5); /* Fondo blanco con 50% de transparencia */
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Sombra para mayor enfoque */
            max-width: 90%; /* Asegura que el div no exceda el ancho de la ventana */
            margin: auto; /* Centra el div horizontalmente */
            position: relative; /* Permite posicionar el div de manera más flexible */
            top: 50%; /* Ajusta la posición vertical */
            transform: translateY(-50%); /* Centra el div verticalmente */
        }

        .ans {
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        .code {
            background-color: #f4f4f4;
            border-left: 4px solid #4CAF50;
            padding: 10px;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        .separator {
            height: 20px; /* Ajusta la altura del separador */
            border-bottom: 1px solid #ccc; /* Ajusta el estilo del borde del separador */
            margin: 20px 0; /* Espaciado superior e inferior */
        }
    </style>
    
</head>
<body>



    <div class="transparente">
        <center><h1> GATOGAME </h1></center>
        

        <h2>DISEÑO DEL JUEGO</h2>

<center><img src="dis.jpeg" alt="Descripción de la imagen" width="400" height="500"></center>
        
            
</div>
<br><br>


<div class="transparente">
        <h1>Clase principal <code>IniciarJuego</code></h1>


        <h2>Métodos:</h2>

        <h3><code>__init__(self, root)</code>:</h3>
        <ul>
            <li>Es el método constructor de la clase que inicializa los atributos y configura el tablero.</li>
            <li>Llama al método <code>iniciar_juego()</code> para crear el tablero y los botones.</li>
        </ul>

        <h2>Atributos:</h2>
        <ul>
            <li><strong><code>self.J1</code></strong>: Representa el símbolo del Jugador 1. En este caso, es "O".</li>
            <li><strong><code>self.J2</code></strong>: Representa el símbolo del Jugador 2. Es "X".</li>
            <li><strong><code>self.tablero</code></strong>: Es una lista de 9 elementos, inicializada vacía (<code>[""] * 9</code>), que representa las casillas del tablero de juego.</li>
            <li><strong><code>self.turno_actual</code></strong>: Almacena qué jugador tiene el turno en ese momento. Inicialmente es <code>self.J1</code>, es decir, el jugador 1.</li>
            <li><strong><code>self.root</code></strong>: Referencia a la ventana principal de la aplicación <code>Tkinter</code>.</li>
            <li><strong><code>self.mensaje</code></strong>: Una variable de tipo <code>StringVar</code> que almacena los mensajes que se mostrarán en la interfaz (por ejemplo, para indicar quién ha ganado o si hay un empate).</li>
        </ul>

</div>
<br><br><br><br><br>






<div class="transparente">
<h2>Desglose del método <strong>iniciar_juego(self)</strong>:</h2>

<ol>
    <li><strong>self.botones = []</strong>
        <ul>
            <li>Se inicializa una lista vacía llamada <code>self.botones</code> para almacenar los botones correspondientes a las casillas del tablero.</li>
            <li>Esta lista se utilizará más tarde para hacer referencia a cada botón, lo que permitirá actualizar su texto y estado.</li>
        </ul>
    </li>
    <li><strong><code>for i in range(9):</code></strong>
        <ul>
            <li>Este bucle <code>for</code> itera 9 veces (del 0 al 8), ya que el tablero tiene 9 casillas en total (3 filas por 3 columnas).</li>
            <li>La variable <code>i</code> representa el índice de cada casilla/botón del tablero.</li>
        </ul>
    </li>
    <li><strong><code>boton = Button(self.root, text="", width=10, height=3, command=lambda i=i: self.ciclo(i))</code></strong>
        <ul>
            <li>Se crea un botón usando el widget <code>Button</code> de <code>tkinter</code>, que pertenece a la ventana principal (<code>self.root</code>).</li>
            <li><strong><code>text=""</code></strong>: El texto del botón se inicializa vacío (ya que la casilla empieza vacía).</li>
            <li><strong><code>width=10, height=3</code></strong>: Define el tamaño del botón (ancho y alto en términos de texto).</li>
            <li><strong><code>command=lambda i=i: self.ciclo(i)</code></strong>: Define qué sucede cuando se hace clic en el botón. En este caso, se utiliza una función <code>lambda</code> que llama al método <code>self.ciclo(i)</code> pasando la posición actual <code>i</code> como argumento. Esto permite que el botón reaccione al clic y ejecute la lógica del turno del juego.</li>
        </ul>
    </li>
    <li><strong><code>boton.grid(row=i // 3, column=i % 3)</code></strong>
        <ul>
            <li>Se utiliza el método <code>grid()</code> para colocar el botón en la ventana principal dentro de una cuadrícula de 3x3.</li>
            <li><strong><code>row=i // 3</code></strong>: Calcula en qué fila debe estar el botón. La división entera (<code>//</code>) asegura que los primeros tres botones (índices 0, 1, 2) estén en la fila 0, los siguientes tres (índices 3, 4, 5) en la fila 1, y así sucesivamente.</li>
            <li><strong><code>column=i % 3</code></strong>: Calcula en qué columna debe ir el botón. El operador módulo (<code>%</code>) asegura que los botones se coloquen en las columnas correctas, es decir, la primera columna (0), la segunda (1) y la tercera (2).</li>
        </ul>
    </li>
    <li><strong><code>self.botones.append(boton)</code></strong>
        <ul>
            <li>Agrega cada botón creado a la lista <code>self.botones</code>. Esto permite que más tarde se pueda acceder a cada botón individualmente para cambiar su texto, deshabilitarlo, o hacer otras modificaciones.</li>
        </ul>
    </li>
    <li><strong><code>Label(self.root, textvariable=self.mensaje).grid(row=3, column=1)</code></strong>
        <ul>
            <li>Crea una etiqueta (<code>Label</code>) que mostrará los mensajes durante el juego (por ejemplo, quién ha ganado o si hay empate).</li>
            <li><strong><code>textvariable=self.mensaje</code></strong>: Se vincula la variable <code>self.mensaje</code> a la etiqueta, de modo que cualquier cambio en <code>self.mensaje</code> automáticamente actualice el texto que se muestra en la interfaz.</li>
            <li><strong><code>grid(row=3, column=1)</code></strong>: Coloca la etiqueta en la fila 3, columna 1, justo debajo del tablero de botones, ya que el tablero utiliza las filas 0 a 2.</li>
        </ul>
    </li>
</ol>
</div>
<br><br><br><br><br><br><br><br>





<div class="transparente">
<h2>Desglose del método <strong>ciclo(self, posicion)</strong>:</h2>

<ol>
    <li><strong><code>if self.tablero[posicion] == "":</code></strong>
        <ul>
            <li>Este <code>if</code> comprueba si la casilla seleccionada está vacía (es decir, no tiene ya un símbolo de jugador).</li>
            <li><strong>Objetivo:</strong> Asegurarse de que el jugador no pueda colocar su símbolo en una casilla que ya ha sido ocupada.</li>
        </ul>
    </li>
    <li><strong><code>self.tablero[posicion] = self.turno_actual</code></strong>
        <ul>
            <li>Se actualiza la lista <code>self.tablero</code> en la posición seleccionada con el símbolo del jugador actual (ya sea "O" o "X").</li>
            <li><strong>Objetivo:</strong> Registrar en la estructura lógica del tablero que el jugador ha ocupado esta casilla.</li>
        </ul>
    </li>
    <li><strong><code>self.botones[posicion].config(text=self.turno_actual)</code></strong>
        <ul>
            <li>Se actualiza el texto del botón en la interfaz gráfica, colocando el símbolo del jugador actual en la casilla correspondiente.</li>
            <li><strong>Objetivo:</strong> Mostrar visualmente el movimiento en el tablero.</li>
        </ul>
    </li>
    <li><strong><code>if self.quien_gana():</code></strong>
        <ul>
            <li>Llama al método <code>quien_gana()</code> para verificar si, después de este movimiento, el jugador actual ha ganado el juego.</li>
            <li><strong>Objetivo:</strong> Comprobar si el jugador ha completado una combinación ganadora.</li>
        </ul>
    </li>
    <li><strong><code>self.mensaje.set(f"¡{self.turno_actual} ha ganado!")</code></strong>
        <ul>
            <li>Si hay un ganador, se actualiza el mensaje en la interfaz gráfica para indicar que el jugador actual ha ganado.</li>
            <li><strong>Objetivo:</strong> Informar al usuario sobre el ganador.</li>
        </ul>
    </li>
    <li><strong><code>self.root.after(2000, self.reiniciar_juego)</code></strong>
        <ul>
            <li>Después de 2 segundos (2000 milisegundos), se llama al método <code>reiniciar_juego()</code> para reiniciar la partida.</li>
            <li><strong>Objetivo:</strong> Permitir que el jugador vea el resultado antes de que el tablero se reinicie.</li>
        </ul>
    </li>
    <li><strong><code>elif all(self.tablero):</code></strong>
        <ul>
            <li>Verifica si todas las casillas del tablero están llenas, lo que significaría un empate si no se ha declarado un ganador.</li>
            <li><strong>Objetivo:</strong> Detectar si el tablero está completo y no hay más movimientos posibles.</li>
        </ul>
    </li>
    <li><strong><code>self.mensaje.set("¡Empate!")</code></strong>
        <ul>
            <li>Si todas las casillas están llenas y no hay ganador, se actualiza el mensaje para indicar que el juego ha terminado en empate.</li>
            <li><strong>Objetivo:</strong> Notificar a los jugadores del empate.</li>
        </ul>
    </li>
    <li><strong><code>self.root.after(2000, self.reiniciar_juego)</code></strong>
        <ul>
            <li>Al igual que en el caso de un ganador, el juego se reinicia después de 2 segundos si ha habido un empate.</li>
            <li><strong>Objetivo:</strong> Permitir que el jugador vea el resultado antes de que el tablero se reinicie.</li>
        </ul>
    </li>
    <li><strong><code>else: self.turno_actual = self.J2 if self.turno_actual == self.J1 else self.J1</code></strong>
        <ul>
            <li>Si no hay ganador y no hay empate, se cambia el turno al siguiente jugador.</li>
            <li><strong>Objetivo:</strong> Alternar el turno entre los jugadores 1 y 2, asegurando que el juego continúe hasta que haya un ganador o un empate.</li>
        </ul>
    </li>
</ol>
</div>
<br><br><br><br>


<br><br><br><br><br><br><br><br><br><br><br>


<div class="transparente">
    <h2>Desglose del método <strong>quien_gana(self)</strong>:</h2>

    <ol>
        <li><strong><code>combinaciones = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]</code></strong>
            <ul>
                <li>Se define una lista de listas, donde cada lista interna contiene una combinación de índices que representan una fila, columna o diagonal ganadora en el tablero.</li>
                <li><strong>Objetivo:</strong> Definir todas las combinaciones posibles que darían lugar a una victoria en el juego (filas, columnas y diagonales).</li>
            </ul>
        </li>
        <li><strong><code>for combinacion in combinaciones:</code></strong>
            <ul>
                <li><strong>Descripción General:</strong> Este bucle recorre cada una de las combinaciones de índices definidas en la lista <code>combinaciones</code>.</li>
                <li><strong>Desglose Detallado:</strong>
                    <ul>
                        <li><strong><code>combinacion</code></strong>: Es una variable que representa cada lista individual dentro de la lista <code>combinaciones</code>. Cada lista de <code>combinaciones</code> contiene tres índices que corresponden a una fila, columna o diagonal en el tablero.</li>
                        <li><strong>Iteración:</strong> En cada iteración del bucle, la variable <code>combinacion</code> toma el valor de una de las listas internas. Por ejemplo, en la primera iteración, <code>combinacion</code> será <code>[0, 1, 2]</code>, en la segunda iteración será <code>[3, 4, 5]</code>, y así sucesivamente.</li>
                        <li><strong>Objetivo:</strong> Evaluar si la combinación actual de índices representa una línea ganadora en el tablero.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong><code>if self.tablero[combinacion[0]] == self.tablero[combinacion[1]] == self.tablero[combinacion[2]] != "":</code></strong>
            <ul>
                <li><strong>Descripción General:</strong> Esta línea verifica si los tres elementos del tablero que corresponden a una combinación específica son iguales y no están vacíos.</li>
                <li><strong>Desglose Detallado:</strong>
                    <ul>
                        <li><strong><code>self.tablero[combinacion[0]]</code></strong>: Accede al valor en la posición del tablero especificada por el primer índice de la combinación actual.</li>
                        <li><strong><code>self.tablero[combinacion[1]]</code></strong>: Accede al valor en la posición del tablero especificada por el segundo índice de la combinación actual.</li>
                        <li><strong><code>self.tablero[combinacion[2]]</code></strong>: Accede al valor en la posición del tablero especificada por el tercer índice de la combinación actual.</li>
                        <li><strong>Comparaciones:</strong>
                            <ul>
                                <li><strong><code>self.tablero[combinacion[0]] == self.tablero[combinacion[1]]</code></strong>: Compara el valor en la primera posición de la combinación con el valor en la segunda posición. Esta comparación verifica si ambos valores son iguales.</li>
                                <li><strong><code>self.tablero[combinacion[1]] == self.tablero[combinacion[2]]</code></strong>: Compara el valor en la segunda posición de la combinación con el valor en la tercera posición. Esta comparación verifica si ambos valores son iguales.</li>
                                <li><strong><code>self.tablero[combinacion[2]] != ""</code></strong>: Verifica que el valor en la tercera posición no esté vacío (o sea, no sea una cadena vacía). Esto asegura que la combinación está completa con un símbolo y no está vacía.</li>
                            </ul>
                        </li>
                        <li><strong>Objetivo:</strong> Asegurarse de que todos los tres valores en la combinación actual sean iguales y que no estén vacíos, lo que indica que un jugador ha logrado una línea completa con el mismo símbolo.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong><code>return True</code></strong>
            <ul>
                <li>Si se cumple la condición anterior, el método devuelve <code>True</code>, lo que indica que hay un ganador.</li>
                <li><strong>Objetivo:</strong> Señalar que alguien ha ganado y el juego debe terminar.</li>
            </ul>
        </li>
        <li><strong><code>return False</code></strong>
            <ul>
                <li>Si ninguna combinación ganadora se ha cumplido, el método retorna <code>False</code>.</li>
                <li><strong>Objetivo:</strong> Indicar que no hay ganador en el estado actual del tablero.</li>
            </ul>
        </li>
    </ol>
    
    






    <h2>Desglose del método <strong>reiniciar_juego(self)</strong>:</h2>

    <ol>
        <li><strong><code>self.tablero = [""] * 9</code></strong>
            <ul>
                <li>Se reinicia la lista <code>self.tablero</code>, estableciendo 9 posiciones vacías.</li>
                <li><strong>Objetivo:</strong> Limpiar el tablero lógico para comenzar una nueva partida.</li>
            </ul>
        </li>
        <li><strong><code>self.turno_actual = self.J1</code></strong>
            <ul>
                <li>Se reinicia el turno para que el jugador 1 (generalmente "X") comience nuevamente.</li>
                <li><strong>Objetivo:</strong> Asegurar que el jugador 1 empiece siempre cuando el juego se reinicie.</li>
            </ul>
        </li>
        <li><strong><code>self.mensaje.set("")</code></strong>
            <ul>
                <li>Se limpia cualquier mensaje previo (como mensajes de victoria o empate) que aparezca en la interfaz gráfica.</li>
                <li><strong>Objetivo:</strong> Restablecer la interfaz para que no muestre mensajes de la partida anterior.</li>
            </ul>
        </li>
        <li><strong><code>for boton in self.botones:</code></strong>
            <ul>
                <li>Se itera sobre cada botón en la lista <code>self.botones</code>.</li>
                <li><strong>Descripción:</strong> Permite aplicar configuraciones a cada botón en la interfaz gráfica del usuario.</li>
                <li><strong>Objetivo:</strong> Restablecer todos los botones en la interfaz de usuario a su estado inicial.</li>
            </ul>
        </li>
        <li><strong><code>boton.config(text="", state=NORMAL)</code></strong>
            <ul>
                <li><strong>Descripción:</strong> Se configura cada botón para que su texto esté vacío y su estado sea <code>NORMAL</code>.</li>
                <li><strong>Objetivo:</strong> Reiniciar el texto en los botones (es decir, borrar cualquier texto que represente los movimientos previos) y habilitar los botones para que puedan ser usados nuevamente.</li>
            </ul>
        </li>
    </ol>
    

            
    
</div>
<br><br><br><br><br><br>



</body>
</body>
</html>
